# dfs
# Import necessary libraries
from collections import deque

# Define the dimensions of the puzzle
N = 3

# Structure to store a state of the puzzle
class PuzzleState:
    def __init__(self, board, x, y, depth):
        self.board = board
        self.x = x
        self.y = y
        self.depth = depth

# Possible moves: Left, Right, Up, Down
row = [0, 0, -1, 1]
col = [-1, 1, 0, 0]

# Function to check if a given state is the goal state
def is_goal_state(board):
    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    return board == goal

# Function to check if a move is valid
def is_valid(x, y):
    return 0 <= x < N and 0 <= y < N

# Function to print the board
def print_board(board):
    for row in board:
        print(' '.join(map(str, row)))
    print("--------")

# Depth-First Search to solve the 8-puzzle problem
def solve_puzzle_dfs(start, x, y):
    stack = []
    visited = set()

    stack.append(PuzzleState(start, x, y, 0))
    visited.add(tuple(map(tuple, start)))

    while stack:
        curr = stack.pop()

        # Print the current board
        print(f'Depth: {curr.depth}')
        print_board(curr.board)

        # Check if goal state is reached
        if is_goal_state(curr.board):
            print(f'Goal state reached at depth {curr.depth}')
            return

        # Explore possible moves
        for i in range(4):
            new_x = curr.x + row[i]
            new_y = curr.y + col[i]

            if is_valid(new_x, new_y):
                new_board = [row[:] for row in curr.board]
                # Swap the tiles
                new_board[curr.x][curr.y], new_board[new_x][new_y] = new_board[new_x][new_y], new_board[curr.x][curr.y]

                # If this state has not been visited before, push to stack
                board_tuple = tuple(map(tuple, new_board))
                if board_tuple not in visited:
                    visited.add(board_tuple)
                    stack.append(PuzzleState(new_board, new_x, new_y, curr.depth + 1))

    print('No solution found (DFS Brute Force reached depth limit)')

# Driver Code
if __name__ == '__main__':
    start = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]
    x, y = 1, 1

    print('Initial State:')
    print_board(start)

    solve_puzzle_dfs(start, x, y)

# bfs
# Import necessary libraries
from collections import deque

# Define the dimensions of the puzzle
N = 3

# Class to represent the state of the puzzle
class PuzzleState:
    def __init__(self, board, x, y, depth):
        self.board = board
        self.x = x
        self.y = y
        self.depth = depth

# Possible moves: Left, Right, Up, Down
row = [0, 0, -1, 1]
col = [-1, 1, 0, 0]

# Function to check if the current state is the goal state
def is_goal_state(board):
    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    return board == goal

# Function to check if a move is valid
def is_valid(x, y):
    return 0 <= x < N and 0 <= y < N

# Function to print the puzzle board
def print_board(board):
    for row in board:
        print(' '.join(map(str, row)))
    print('--------')

# BFS function to solve the 8-puzzle problem
def solve_puzzle_bfs(start, x, y):
    q = deque()
    visited = set()

    # Enqueue initial state
    q.append(PuzzleState(start, x, y, 0))
    visited.add(tuple(map(tuple, start)))

    while q:
        curr = q.popleft()

        # Print the current board state
        print(f'Depth: {curr.depth}')
        print_board(curr.board)

        # Check if goal state is reached
        if is_goal_state(curr.board):
            print(f'Goal state reached at depth {curr.depth}')
            return

        # Explore all possible moves
        for i in range(4):
            new_x = curr.x + row[i]
            new_y = curr.y + col[i]

            if is_valid(new_x, new_y):
                new_board = [row[:] for row in curr.board]
                new_board[curr.x][curr.y], new_board[new_x][new_y] = new_board[new_x][new_y], new_board[curr.x][curr.y]

                # If this state has not been visited before, push to queue
                if tuple(map(tuple, new_board)) not in visited:
                    visited.add(tuple(map(tuple, new_board)))
                    q.append(PuzzleState(new_board, new_x, new_y, curr.depth + 1))

    print('No solution found (BFS Brute Force reached depth limit)')

# Driver Code
if __name__ == '__main__':
    start = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]  # Initial state
    x, y = 1, 1

    print('Initial State:')
    print_board(start)

    solve_puzzle_bfs(start, x, y)

# best first search
import heapq

GOAL = (
    (1, 2, 3),
    (4, 5, 6),
    (7, 8, 0)
)
# Precompute goal positions for Manhattan distance
goal_pos = {}
for i in range(3):
    for j in range(3):
        goal_pos[GOAL[i][j]] = (i, j)

def manhattan(state):
    dist = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val != 0:
                gi, gj = goal_pos[val]
                dist += abs(i - gi) + abs(j - gj)
    return dist

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def get_neighbors(state):
    x, y = find_blank(state)
    moves = []
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [list(row) for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            moves.append(tuple(tuple(row) for row in new_state))

    return moves

def best_first_search(start):
    pq = []
    visited = set()

    heapq.heappush(pq, (manhattan(start), start, []))

    while pq:
        h, state, path = heapq.heappop(pq)

        if state in visited:
            continue
        visited.add(state)

        if state == GOAL:
            return path + [state]

        for neighbor in get_neighbors(state):
            if neighbor not in visited:
                heapq.heappush(
                    pq,
                    (manhattan(neighbor), neighbor, path + [state])
                )

    return None

def print_solution(path):
    for step, state in enumerate(path):
        print(f"Step {step}:")
        for row in state:
            print(row)
        print()

# Example start state
START = (
    (1, 2, 3),
    (4, 0, 6),
    (7, 5, 8)
)

solution = best_first_search(START)

if solution:
    print_solution(solution)
else:
    print("No solution found.")  


# a*
# astart
import numpy as np
import time
import os
import sys
import heapq

N = 3

# moves: left, right, up, down
row = [0, 0, -1, 1]
col = [-1, 1, 0, 0]

def is_valid(x, y):
    return 0 <= x < N and 0 <= y < N

def is_goal(board):
    goal = [[1, 2, 3],
            [4, 5, 6],
            [7, 8, 0]]
    return board == goal

def manhattan(board):
    h = 0
    for i in range(N):
        for j in range(N):
            val = board[i][j]
            if val != 0:
                goal_row = (val - 1) // N
                goal_col = (val - 1) % N
                h += abs(i - goal_row) + abs(j - goal_col)
    return h

def astar(start_board, x, y):
    pq = []                      # priority queue
    visited = set()

    g = 0
    h = manhattan(start_board)
    f = g + h

    heapq.heappush(pq, (f, g, start_board, x, y))
    visited.add(tuple(map(tuple, start_board)))

    while pq:
        f, g, board, bx, by = heapq.heappop(pq)

        if is_goal(board):
            print("Solution found at depth:", g)
            return

        for i in range(4):
            nx = bx + row[i]
            ny = by + col[i]

            if is_valid(nx, ny):
                new_board = [r[:] for r in board]

                # swap blank with neighbor
                new_board[bx][by], new_board[nx][ny] = (
                    new_board[nx][ny],
                    new_board[bx][by]
                )

                t = tuple(map(tuple, new_board))

                if t not in visited:
                    visited.add(t)
                    new_g = g + 1
                    new_h = manhattan(new_board)
                    new_f = new_g + new_h

                    heapq.heappush(
                        pq,
                        (new_f, new_g, new_board, nx, ny)
                    )

    print("No solution found")

# Example
start_board = [[1, 2, 3],
               [4, 5, 6],
               [7, 0, 8]]

astar(start_board, 2, 1)


# aostar
N = 3
GOAL = [[1, 2, 3],
        [4, 5, 6],
        [7, 8, 0]]

def is_goal(board):
    return board == GOAL

def manhattan(board):
    h = 0
    for i in range(N):
        for j in range(N):
            val = board[i][j]
            if val != 0:
                goal_row = (val-1)//N
                goal_col = (val-1)%N
                h += abs(i - goal_row) + abs(j - goal_col)
    return h

def find_blank(board):
    for i in range(N):
        for j in range(N):
            if board[i][j] == 0:
                return i, j

def get_neighbors(board):
    x, y = find_blank(board)
    neighbors = []
    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
        nx, ny = x+dx, y+dy
        if 0 <= nx < N and 0 <= ny < N:
            new_board = [r[:] for r in board]
            new_board[x][y], new_board[nx][ny] = new_board[nx][ny], new_board[x][y]
            neighbors.append(new_board)
    return neighbors

def ao_star(board, visited=None, path=None):
    if visited is None:
        visited = set()
    if path is None:
        path = []

    t = tuple(map(tuple, board))
    if t in visited:
        return None  # dead end
    visited.add(t)

    path = path + [board]  # extend path

    if is_goal(board):
        return path  # goal reached

    # Get neighbors and sort by f = g + h
    neighbors = get_neighbors(board)
    neighbors.sort(key=lambda b: manhattan(b))

    for neighbor in neighbors:
        result = ao_star(neighbor, visited, path)
        if result:
            return result  # OR-node: pick first successful child

    return None  # no solution found

# Example usage
start_board = [[1,2,3],
               [4,0,6],
               [7,5,8]]

solution_path = ao_star(start_board)

if solution_path:
    print("Solution found! Steps:", len(solution_path)-1)
    for step, board in enumerate(solution_path):
        print(f"Step {step}, Heuristic = {manhattan(board)}")
        for row in board:
            print(row)
        print()
else:
    print("No solution found.")

# hill climb
N = 3
row = [0, 0, -1, 1]  
col = [-1, 1, 0, 0]

GOAL = [[1, 2, 3],
        [4, 5, 6],
        [7, 8, 0]]


def is_valid(x, y):
    return 0 <= x < N and 0 <= y < N


def is_goal(board):
    return board == GOAL


def manhattan(board):
    h = 0
    for i in range(N):
        for j in range(N):
            val = board[i][j]
            if val != 0:
                goal_row = (val - 1) // N
                goal_col = (val - 1) % N
                h += abs(i - goal_row) + abs(j - goal_col)
    return h


def find_blank(board):
    for i in range(N):
        for j in range(N):
            if board[i][j] == 0:
                return i, j


def get_neighbors(board):
    x, y = find_blank(board)
    neighbors = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if is_valid(nx, ny):
            new_board = [r[:] for r in board]
            new_board[x][y], new_board[nx][ny] = new_board[nx][ny], new_board[x][y]
            neighbors.append(new_board)
    return neighbors


def hill_climbing(start_board, max_steps=1000):
    current = start_board
    for step in range(max_steps):
        print(f"Step {step}, heuristic: {manhattan(current)}")
        if is_goal(current):
            print("Goal reached!")
            return current

        neighbors = get_neighbors(current)
        # Choose neighbor with lowest heuristic
        next_board = min(neighbors, key=manhattan)

        # If no improvement, local maxima reached
        if manhattan(next_board) >= manhattan(current):
            print("Stuck at local maxima or plateau.")
            return current

        current = next_board

    print("Max steps reached without solution.")
    return current


start_board = [[1, 2, 3],
               [4, 0, 6],
               [7, 5, 8]]

hill_climbing(start_board)

Prolog

#Basic
min-max
find_max(X, Y, X) :- X >= Y, !.
find_max(X, Y, Y) :- X < Y.
find_min(X, Y, X) :- X =< Y, !.
find_min(X, Y, Y) :- X > Y.
circuit

series(R1,R2,Re) :- Re is R1 + R2.
parallel(R1,R2,Re) :- Re is ((R1 * R2) / (R1 + R2)).

lines
vertical(seg(point(X,_),point(X,_))).
horizontal(seg(point(_,Y),point(_,Y))).
oblique(seg(point(X1,Y1),point(X2,Y2))) :- X1 \== X2, Y1 \== Y2.

#Arithmetic
area

area_rectangle(Length, Breadth, Area) :- Area is Length * Breadth.
degree
celsius_to_fahrenheit(C, F) :- F is C * 9 / 5 + 32.
factorial
factorial(0, 1).
factorial(N, Result) :- N > 0, N_minus_1 is N - 1, factorial(N_minus_1, SubResult), Result is N * SubResult.
query factorial(5,F)

#tower of hanoi
move(1,X,Y,_) :-   write('Move top disk from '), write(X), write(' to '), write(Y), nl.
move(N,X,Y,Z) :-   N>1,   M is N-1,   move(M,X,Z,Y),   move(1,X,Y,_),   move(M,Z,Y,X).
query:
write(3,source,target,auxiliary)

#monkey
move(state(middle,onbox,middle,hasnot),   grasp,   state(middle,onbox,middle,has)).
move(state(P,onfloor,P,H),   climb,   state(P,onbox,P,H)).
move(state(P1,onfloor,P1,H),   drag(P1,P2),   state(P2,onfloor,P2,H)).
move(state(P1,onfloor,B,H),   walk(P1,P2),   state(P2,onfloor,B,H)).
canget(state(_,_,_,has)).
canget(State1) :-   move(State1,_,State2),   canget(State2).
querey:
canget(state(atdoor,onfloor,atwindow,hasnot)),
write("Yes, the monkey can get banana"),nl.